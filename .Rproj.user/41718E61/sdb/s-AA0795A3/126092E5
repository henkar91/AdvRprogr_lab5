{
    "collab_server" : "",
    "contents" : "#' @title INQStats data query\n#' @field api_key a key received from INQStats.\n#' @field country_code a vector of ISO 3166-1 country codes, e.g. \"us,gb,se\".\n#' @field data a data-set, as a vector, e.g. c(\"population\",\"birth_rate\").\n#' @field years a year range, as a vector, e.g.  1990:2002.\n#' @field result a data frame.\n#' @description Returns the data from INQStats.\n#' Further information about  INQStats, e.g. how to get api key, what data is available, can be found on \\url{http://blog.inqubu.com/inqstats-open-api-published-to-get-demographic-data}\n#' @examples\n#' databycountry$new(api_key= \"97c1f72e01dd5ba3\", country_code = \"us,lt,se\", data = c(\"population\",\"birth_rate\",\"co2_emissions\",\"fifa\",\"hdi\"),years = 1990:2015)$result\n#' @export databycountry\n#' @export\n\n\ndatabycountry <-  setRefClass(\n    \"databycountry\",\n    \n    # Things to do:\n    # not sure if makes sense to have 'data' field as vector?.. It makes sense to have years as vector cause no one can be bothered to list out all years in the range (this is the format that you expect to receive)\n    # however, if we insist user to provide 'data' as a character string they might add some random spaces or forget commas, so maybe vector is 'safer' option...\n    # We need to ask Krzysztof if this way of getting result is ok  (see example at the bottom). I believe it should be fine as long as we properly document the package and provide the examples in documentation or vignette\n    # Also need to think about country_code, now the code only works if we provide one country_code. If we provide two or more countries, the response from API is no longer data.frame format which means we would need to format it ourselves.. NOt sure how flexibal our function has to be.\n    \n    fields = list(\n        # api key is provided by the INQStats, our key is \"97c1f72e01dd5ba3\"\n        api_key = \"character\",\n        # two letter ISO 3166-1 country code\n        country_code = \"vector\",\n        # what information is required, i.e., population, birth_rate... http://blog.inqubu.com/inqstats-open-api-published-to-get-demographic-data\n        data  = \"vector\",\n        # numeric vector of how many years info user needs\n        years = \"vector\",\n        result = \"data.frame\"\n    ),\n    methods = list(\n        initialize = function(api_key, country_code, data, years) {\n            # Add neccessary libraries\n            library(jsonlite)\n            library(httr)\n            \n            stopifnot(is.numeric(years),is.vector(years))\n            stopifnot(is.character(country_code),is.vector(country_code))\n            stopifnot(is.character(data),is.vector(data))\n            stopifnot(is.character(api_key),length(api_key)==1)\n\n            # Create character string without spaces of country_code\n            country_ch <- gsub(\" \", \"\", toString(country_code), fixed = TRUE)\n            # Create character string without spaces of years\n            years_ch <- gsub(\" \", \"\", toString(years), fixed = TRUE)\n            # Create character string without spaces of data\n            data_ch <- gsub(\" \", \"\", toString(data), fixed = TRUE)\n            \n            # Create return of fields\n            api_key <<- api_key\n            country_code <<- country_ch\n            data <<- data_ch\n            years <<- years_ch\n            \n            # Call API server\n            url <-  \"http://inqstatsapi.inqubu.com\"\n            raw_result <-\n                GET(\n                    url,\n                    query = list(\n                        api_key = api_key,\n                        countries = country_ch,\n                        data = data_ch,\n                        years = years_ch\n                    )\n                )\n            \n            # Parse the response from JSON to R\n            raw_content <- rawToChar(raw_result$content)\n            \n            # INQStats\n            if (http_type(raw_result) != \"application/json\") {\n                resp_string <- substr(raw_content, 2, nchar(raw_content) - 1)\n                if (grep(\"error\", resp_string) == 1) {\n                    stop(sprintf(\n                        \"API did not return json.\\n Response:<%s>\",\n                        resp_string\n                    ),\n                    call. = FALSE)\n                    \n                }\n                else{\n                    stop(\"API did not return json\", call. = FALSE)\n                    \n                }\n            }\n            \n            # use function from jsonlite to convert response to R data frame\n            df_content <- fromJSON(raw_content)\n            \n            if (df_content[[1]] == \"error\" ||\n                http_error(raw_result)) {\n                stop(\n                    sprintf(\n                        \"INQStats API request failed.\\nstatus_code:[%s]\\nmsg:<%s>\",\n                        status_code(raw_result),\n                        df_content$msg\n                    ),\n                    call. = FALSE\n                )\n            }\n            \n            \n            \n            df_output <- data.frame(\n                country = character(),\n                dataset = character(),\n                years = numeric(),\n                values = numeric()\n            )\n            \n            for (i in 1:length(df_content[[1]])) {\n                country_name <- df_content$countryName[i]\n                \n                # loop through all datasets (exclude countryCode and countryName)\n                for (j in 3:length(df_content)) {\n                    # Skip this iterration if this dataset is empty (no values received from API)\n                    if (length(df_content[[j]][[i]]) == 0) {\n                        next\n                    }\n                    # take years of the jth dataset for the ith country\n                    years_j <- df_content[[j]][[i]][[1]]\n                    # take value of the jth dataset for the ith country\n                    value_j <- df_content[[j]][[i]][[2]]\n                    # create vestor of countryNames\n                    country_j <-\n                        rep.int(country_name, length(value_j))\n                    # Create vector of dataset name\n                    dataset_j <-\n                        rep.int(names(df_content)[j], length(value_j))\n                    # create temp dataframe\n                    output_temp <- data.frame(\n                        country = country_j,\n                        dataset = dataset_j,\n                        years = years_j,\n                        values = value_j\n                    )\n                    \n                    # merge the rows to df_output\n                    df_output <- rbind(df_output, output_temp)\n                }\n                \n                \n            }\n            result <<- df_output\n        }\n    )\n)\n# to query the results of this follow the example below:\n# test2 <- databycountry$new(api_key= \"97c1f72e01dd5ba3\", country_code = \"us\", data = c(\"population\",\"birth_rate\"),years = 1990:2000)\n# test2$result$population\n# test2$result$birth_rate\n",
    "created" : 1506687516378.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2727929437",
    "id" : "126092E5",
    "lastKnownWriteTime" : 1506692913,
    "last_content_update" : 1506692913410,
    "path" : "~/R/Advanced R course/AdvRprogr_lab5/INQStatsR/R/databycountry.R",
    "project_path" : "INQStatsR/R/databycountry.R",
    "properties" : {
        "source_window_id" : ""
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}