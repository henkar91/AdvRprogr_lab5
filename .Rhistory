# not sure if makes sense to have 'data' field as vector?.. It makes sense to have years as vector cause no one can be bothered to list out all years in the range (this is the format that you expect to receive)
# however, if we insist user to provide 'data' as a character string they might add some random spaces or forget commas, so maybe vector is 'safer' option...
# We need to ask Krzysztof if this way of getting result is ok  (see example at the bottom). I believe it should be fine as long as we properly document the package and provide the examples in documentation or vignette
# Also need to think about country_code, now the code only works if we provide one country_code. If we provide two or more countries, the response from API is no longer data.frame format which means we would need to format it ourselves.. NOt sure how flexibal our function has to be.
fields = list(
# api key is provided by the INQStats, our key is "97c1f72e01dd5ba3"
api_key = "character",
# two letter ISO 3166-1 country code
country_code = "vector",
# what information is required, i.e., population, birth_rate... http://blog.inqubu.com/inqstats-open-api-published-to-get-demographic-data
data  = "vector",
# numeric vector of how many years info user needs
years = "vector",
result = "data.frame"
),
methods = list(
initialize = function(api_key, country_code, data, years) {
# Add neccessary libraries
library(jsonlite)
library(httr)
# Create character string without spaces of country_code
country_ch <- gsub(" ", "", toString(country_code), fixed = TRUE)
# Create character string without spaces of years
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
# Create character string without spaces of data
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
# Create return of fields
api_key <<- api_key
country_code <<- country_ch
data <<- data_ch
years <<- years_ch
# Call API server
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_ch,
data = data_ch,
years = years_ch
)
)
# Parse the response from JSON to R
raw_content <- rawToChar(raw_result$content)
# INQStats
if (http_type(raw_result) != "application/json") {
resp_string <- substr(raw_content, 2, nchar(raw_content) - 1)
if (grep("error", resp_string) == 1) {
stop(sprintf(
"API did not return json.\n Response:<%s>",
resp_string
),
call. = FALSE)
}
else{
stop("API did not return json", call. = FALSE)
}
}
# use function from jsonlite to convert response to R data frame
df_content <- fromJSON(raw_content)
if (df_content[[1]] == "error" ||
http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed.\nstatus_code:[%s]\nmsg:<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
df_output <- data.frame(
country = character(),
dataset = character(),
years = numeric(),
values = numeric()
)
for (i in 1:length(df_content[[1]])) {
country_name <- df_content$countryName[i]
# loop through all datasets (exclude countryCode and countryName)
for (j in 3:length(df_content)) {
# Skip this iterration if this dataset is empty (no values received from API)
if (length(df_content[[j]][[i]]) == 0) {
next
}
# take years of the jth dataset for the ith country
years_j <- df_content[[j]][[i]][[1]]
# take value of the jth dataset for the ith country
value_j <- df_content[[j]][[i]][[2]]
# create vestor of countryNames
country_j <-
rep.int(country_name, length(value_j))
# Create vector of dataset name
dataset_j <-
rep.int(names(df_content)[j], length(value_j))
# create temp dataframe
output_temp <- data.frame(
country = country_j,
dataset = dataset_j,
years = years_j,
values = value_j
)
# merge the rows to df_output
df_output <- rbind(df_output, output_temp)
}
}
result <<- df_output
},
country = function(){
return(unique(result[["country"]]))
},
dataset = function(){
return(unique(result[["dataset"]]))
}
)
)
test2 <- databycountry$new(api_key= "97c1f72e01dd5ba3",
country_code = "us,se",
data = c("population","birth_rate"),
years = 1998:2000)
test2$country
test2$data
head(test2$result, 10)
result[["country"]]
result <- (test2$result)
result[["country"]]
result[["dataset"]]
result
test2 <- databycountry$new(api_key= "97c1f72e01dd5ba3",
country_code = "us,se",
data = c("population","birth_rate"),
years = 1999:2000)
test2$country
test2$dataset
test2$country
test2$dataset
test2$dataset()
test2$country()
databycountry <-  setRefClass(
"databycountry",
# Things to do:
# not sure if makes sense to have 'data' field as vector?.. It makes sense to have years as vector cause no one can be bothered to list out all years in the range (this is the format that you expect to receive)
# however, if we insist user to provide 'data' as a character string they might add some random spaces or forget commas, so maybe vector is 'safer' option...
# We need to ask Krzysztof if this way of getting result is ok  (see example at the bottom). I believe it should be fine as long as we properly document the package and provide the examples in documentation or vignette
# Also need to think about country_code, now the code only works if we provide one country_code. If we provide two or more countries, the response from API is no longer data.frame format which means we would need to format it ourselves.. NOt sure how flexibal our function has to be.
fields = list(
# api key is provided by the INQStats, our key is "97c1f72e01dd5ba3"
api_key = "character",
# two letter ISO 3166-1 country code
country_code = "vector",
# what information is required, i.e., population, birth_rate... http://blog.inqubu.com/inqstats-open-api-published-to-get-demographic-data
data  = "vector",
# numeric vector of how many years info user needs
years = "vector",
result = "data.frame"
),
methods = list(
initialize = function(api_key, country_code, data, years) {
# Add neccessary libraries
library(jsonlite)
library(httr)
# Create character string without spaces of country_code
country_ch <- gsub(" ", "", toString(country_code), fixed = TRUE)
# Create character string without spaces of years
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
# Create character string without spaces of data
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
# Create return of fields
api_key <<- api_key
country_code <<- country_ch
data <<- data_ch
years <<- years_ch
# Call API server
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_ch,
data = data_ch,
years = years_ch
)
)
# Parse the response from JSON to R
raw_content <- rawToChar(raw_result$content)
# INQStats
if (http_type(raw_result) != "application/json") {
resp_string <- substr(raw_content, 2, nchar(raw_content) - 1)
if (grep("error", resp_string) == 1) {
stop(sprintf(
"API did not return json.\n Response:<%s>",
resp_string
),
call. = FALSE)
}
else{
stop("API did not return json", call. = FALSE)
}
}
# use function from jsonlite to convert response to R data frame
df_content <- fromJSON(raw_content)
if (df_content[[1]] == "error" ||
http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed.\nstatus_code:[%s]\nmsg:<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
df_output <- data.frame(
country = character(),
dataset = character(),
years = numeric(),
values = numeric()
)
for (i in 1:length(df_content[[1]])) {
country_name <- df_content$countryName[i]
# loop through all datasets (exclude countryCode and countryName)
for (j in 3:length(df_content)) {
# Skip this iterration if this dataset is empty (no values received from API)
if (length(df_content[[j]][[i]]) == 0) {
next
}
# take years of the jth dataset for the ith country
years_j <- df_content[[j]][[i]][[1]]
# take value of the jth dataset for the ith country
value_j <- df_content[[j]][[i]][[2]]
# create vestor of countryNames
country_j <-
rep.int(country_name, length(value_j))
# Create vector of dataset name
dataset_j <-
rep.int(names(df_content)[j], length(value_j))
# create temp dataframe
output_temp <- data.frame(
country = country_j,
dataset = dataset_j,
years = years_j,
values = value_j
)
# merge the rows to df_output
df_output <- rbind(df_output, output_temp)
}
}
result <<- df_output
},
country = function(){
return(as.vector(unique(result[["country"]])))
},
dataset = function(){
return(unique(result[["dataset"]]))
}
)
)
test2 <- databycountry$new(api_key= "97c1f72e01dd5ba3",
country_code = "us,se",
data = c("population","birth_rate"),
years = 1999:2000)
test2$country()
databycountry <-  setRefClass(
"databycountry",
# Things to do:
# not sure if makes sense to have 'data' field as vector?.. It makes sense to have years as vector cause no one can be bothered to list out all years in the range (this is the format that you expect to receive)
# however, if we insist user to provide 'data' as a character string they might add some random spaces or forget commas, so maybe vector is 'safer' option...
# We need to ask Krzysztof if this way of getting result is ok  (see example at the bottom). I believe it should be fine as long as we properly document the package and provide the examples in documentation or vignette
# Also need to think about country_code, now the code only works if we provide one country_code. If we provide two or more countries, the response from API is no longer data.frame format which means we would need to format it ourselves.. NOt sure how flexibal our function has to be.
fields = list(
# api key is provided by the INQStats, our key is "97c1f72e01dd5ba3"
api_key = "character",
# two letter ISO 3166-1 country code
country_code = "vector",
# what information is required, i.e., population, birth_rate... http://blog.inqubu.com/inqstats-open-api-published-to-get-demographic-data
data  = "vector",
# numeric vector of how many years info user needs
years = "vector",
result = "data.frame"
),
methods = list(
initialize = function(api_key, country_code, data, years) {
# Add neccessary libraries
library(jsonlite)
library(httr)
# Create character string without spaces of country_code
country_ch <- gsub(" ", "", toString(country_code), fixed = TRUE)
# Create character string without spaces of years
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
# Create character string without spaces of data
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
# Create return of fields
api_key <<- api_key
country_code <<- country_ch
data <<- data_ch
years <<- years_ch
# Call API server
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_ch,
data = data_ch,
years = years_ch
)
)
# Parse the response from JSON to R
raw_content <- rawToChar(raw_result$content)
# INQStats
if (http_type(raw_result) != "application/json") {
resp_string <- substr(raw_content, 2, nchar(raw_content) - 1)
if (grep("error", resp_string) == 1) {
stop(sprintf(
"API did not return json.\n Response:<%s>",
resp_string
),
call. = FALSE)
}
else{
stop("API did not return json", call. = FALSE)
}
}
# use function from jsonlite to convert response to R data frame
df_content <- fromJSON(raw_content)
if (df_content[[1]] == "error" ||
http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed.\nstatus_code:[%s]\nmsg:<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
df_output <- data.frame(
country = character(),
dataset = character(),
years = numeric(),
values = numeric()
)
for (i in 1:length(df_content[[1]])) {
country_name <- df_content$countryName[i]
# loop through all datasets (exclude countryCode and countryName)
for (j in 3:length(df_content)) {
# Skip this iterration if this dataset is empty (no values received from API)
if (length(df_content[[j]][[i]]) == 0) {
next
}
# take years of the jth dataset for the ith country
years_j <- df_content[[j]][[i]][[1]]
# take value of the jth dataset for the ith country
value_j <- df_content[[j]][[i]][[2]]
# create vestor of countryNames
country_j <-
rep.int(country_name, length(value_j))
# Create vector of dataset name
dataset_j <-
rep.int(names(df_content)[j], length(value_j))
# create temp dataframe
output_temp <- data.frame(
country = country_j,
dataset = dataset_j,
years = years_j,
values = value_j
)
# merge the rows to df_output
df_output <- rbind(df_output, output_temp)
}
}
result <<- df_output
},
country = function(){
return(unique(result[["country"]]))
},
dataset = function(){
return(unique(result[["dataset"]]))
}
)
)
test2 <- databycountry$new(api_key= "97c1f72e01dd5ba3",
country_code = "us,se",
data = c("population","birth_rate"),
years = 1999:2000)
test2$country()
test2$dataset()
unique(result[["dataset"]])
as.vector(unique(result[["dataset"]]))
databycountry <-  setRefClass(
"databycountry",
# Things to do:
# not sure if makes sense to have 'data' field as vector?.. It makes sense to have years as vector cause no one can be bothered to list out all years in the range (this is the format that you expect to receive)
# however, if we insist user to provide 'data' as a character string they might add some random spaces or forget commas, so maybe vector is 'safer' option...
# We need to ask Krzysztof if this way of getting result is ok  (see example at the bottom). I believe it should be fine as long as we properly document the package and provide the examples in documentation or vignette
# Also need to think about country_code, now the code only works if we provide one country_code. If we provide two or more countries, the response from API is no longer data.frame format which means we would need to format it ourselves.. NOt sure how flexibal our function has to be.
fields = list(
# api key is provided by the INQStats, our key is "97c1f72e01dd5ba3"
api_key = "character",
# two letter ISO 3166-1 country code
country_code = "vector",
# what information is required, i.e., population, birth_rate... http://blog.inqubu.com/inqstats-open-api-published-to-get-demographic-data
data  = "vector",
# numeric vector of how many years info user needs
years = "vector",
result = "data.frame"
),
methods = list(
initialize = function(api_key, country_code, data, years) {
# Add neccessary libraries
library(jsonlite)
library(httr)
# Create character string without spaces of country_code
country_ch <- gsub(" ", "", toString(country_code), fixed = TRUE)
# Create character string without spaces of years
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
# Create character string without spaces of data
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
# Create return of fields
api_key <<- api_key
country_code <<- country_ch
data <<- data_ch
years <<- years_ch
# Call API server
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_ch,
data = data_ch,
years = years_ch
)
)
# Parse the response from JSON to R
raw_content <- rawToChar(raw_result$content)
# INQStats
if (http_type(raw_result) != "application/json") {
resp_string <- substr(raw_content, 2, nchar(raw_content) - 1)
if (grep("error", resp_string) == 1) {
stop(sprintf(
"API did not return json.\n Response:<%s>",
resp_string
),
call. = FALSE)
}
else{
stop("API did not return json", call. = FALSE)
}
}
# use function from jsonlite to convert response to R data frame
df_content <- fromJSON(raw_content)
if (df_content[[1]] == "error" ||
http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed.\nstatus_code:[%s]\nmsg:<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
df_output <- data.frame(
country = character(),
dataset = character(),
years = numeric(),
values = numeric()
)
for (i in 1:length(df_content[[1]])) {
country_name <- df_content$countryName[i]
# loop through all datasets (exclude countryCode and countryName)
for (j in 3:length(df_content)) {
# Skip this iterration if this dataset is empty (no values received from API)
if (length(df_content[[j]][[i]]) == 0) {
next
}
# take years of the jth dataset for the ith country
years_j <- df_content[[j]][[i]][[1]]
# take value of the jth dataset for the ith country
value_j <- df_content[[j]][[i]][[2]]
# create vestor of countryNames
country_j <-
rep.int(country_name, length(value_j))
# Create vector of dataset name
dataset_j <-
rep.int(names(df_content)[j], length(value_j))
# create temp dataframe
output_temp <- data.frame(
country = country_j,
dataset = dataset_j,
years = years_j,
values = value_j
)
# merge the rows to df_output
df_output <- rbind(df_output, output_temp)
}
}
result <<- df_output
},
country = function(){
return(unique(result[["country"]]))
},
dataset = function(){
return(as.vector(unique(result[["dataset"]])))
}
)
)
