# loop through all datasets (exclude countryCode and countryName)
for (j in 3:length(df_content)) {
# Skip this iterration if this dataset is empty (no values received from API)
if (length(df_content[[j]][[i]]) == 0) {
next
}
# take years of the jth dataset for the ith country
years_j <- df_content[[j]][[i]][[1]]
# take value of the jth dataset for the ith country
value_j <- df_content[[j]][[i]][[2]]
# create vestor of countryNames
country_j <-
rep.int(country_name, length(value_j))
# Create vector of dataset name
dataset_j <-
rep.int(names(df_content)[j], length(value_j))
# create temp dataframe
output_temp <- data.frame(
country = country_j,
dataset = dataset_j,
years = years_j,
values = value_j
)
# merge the rows to df_output
df_output <- rbind(df_output, output_temp)
}
}
result <<- df_output
}
)
)
databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)$result
databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)$result
library(INQStatsR)
library(INQStatsR)
library(INQStatsR)
library(INQStatsR)
library(INQStatsR)
library(INQStatsR)
devtools::use_vignette("INQStatsR-vignette")
browseVignettes("jsonlite")
browseVignettes("ggplot2")
?http_error
?sprintf
api_key = "97c1f72e01dd5ba3"
country_code = "us,gb,se"
data = c("population","birth_rate")
data = c("population","birth_rate","co2_emissions","fifa","hdi")
years = 1990:2000
databycountry <-  setRefClass(
"databycountry",
# Things to do:
# not sure if makes sense to have 'data' field as vector?.. It makes sense to have years as vector cause no one can be bothered to list out all years in the range (this is the format that you expect to receive)
# however, if we insist user to provide 'data' as a character string they might add some random spaces or forget commas, so maybe vector is 'safer' option...
# We need to ask Krzysztof if this way of getting result is ok  (see example at the bottom). I believe it should be fine as long as we properly document the package and provide the examples in documentation or vignette
# Also need to think about country_code, now the code only works if we provide one country_code. If we provide two or more countries, the response from API is no longer data.frame format which means we would need to format it ourselves.. NOt sure how flexibal our function has to be.
# If we want to be bale to compare data from different countries, we need to have countru_code vector and then extend code that if length(country_code)>1 [prepare a df manually from the results]
fields = list(
# api key is provided by the INQStats, our key is "97c1f72e01dd5ba3"
api_key = "character",
# two letter ISO 3166-1 country code
country_code = "character",
# what information is required, i.e., population, birth_rate... http://blog.inqubu.com/inqstats-open-api-published-to-get-demographic-data
data  = "vector",
# numeric vector of how many years info user needs
years = "vector",
result = "data.frame"
),
methods = list(
initialize = function(api_key, country_code, data, years) {
# Create character string without spaces of country_code
# country_ch <- gsub(" ", "", toString(country_code), fixed = TRUE)
# Create character string without spaces of years
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
# Create character string without spaces of data
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_code,
data = data_ch,
years = years_ch
)
)
if (http_type(raw_result) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Parse the response from JSON to R
raw_content <- rawToChar(raw_result$content)
# use function from jsonlite to convert response to R data frame
df_content <- fromJSON(raw_content)
if (http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed [%s]\n%s\n<%s>",
status_code(raw_result),
df_content$message,
df_content$documentation_url
),
call. = FALSE
)
}
df_output <- data.frame(
country = character(),
dataset = character(),
years = numeric(),
values = numeric()
)
for (i in 1:length(df_content[[1]])) {
country_name <- df_content$countryName[i]
# loop through all datasets (exclude countryCode and countryName)
for (j in 3:length(df_content)) {
# Skip this iterration if this dataset is empty (no values received from API)
if (length(df_content[[j]][[i]]) == 0) {
next
}
# take years of the jth dataset for the ith country
years_j <- df_content[[j]][[i]][[1]]
# take value of the jth dataset for the ith country
value_j <- df_content[[j]][[i]][[2]]
# create vestor of countryNames
country_j <-
rep.int(country_name, length(value_j))
# Create vector of dataset name
dataset_j <-
rep.int(names(df_content)[j], length(value_j))
# create temp dataframe
output_temp <- data.frame(
country = country_j,
dataset = dataset_j,
years = years_j,
values = value_j
)
# merge the rows to df_output
df_output <- rbind(df_output, output_temp)
}
}
result <<- df_output
}
)
)
databycountry <-  setRefClass(
"databycountry",
# Things to do:
# not sure if makes sense to have 'data' field as vector?.. It makes sense to have years as vector cause no one can be bothered to list out all years in the range (this is the format that you expect to receive)
# however, if we insist user to provide 'data' as a character string they might add some random spaces or forget commas, so maybe vector is 'safer' option...
# We need to ask Krzysztof if this way of getting result is ok  (see example at the bottom). I believe it should be fine as long as we properly document the package and provide the examples in documentation or vignette
# Also need to think about country_code, now the code only works if we provide one country_code. If we provide two or more countries, the response from API is no longer data.frame format which means we would need to format it ourselves.. NOt sure how flexibal our function has to be.
# If we want to be bale to compare data from different countries, we need to have countru_code vector and then extend code that if length(country_code)>1 [prepare a df manually from the results]
fields = list(
# api key is provided by the INQStats, our key is "97c1f72e01dd5ba3"
api_key = "character",
# two letter ISO 3166-1 country code
country_code = "character",
# what information is required, i.e., population, birth_rate... http://blog.inqubu.com/inqstats-open-api-published-to-get-demographic-data
data  = "vector",
# numeric vector of how many years info user needs
years = "vector",
result = "data.frame"
),
methods = list(
initialize = function(api_key, country_code, data, years) {
# Create character string without spaces of country_code
# country_ch <- gsub(" ", "", toString(country_code), fixed = TRUE)
# Create character string without spaces of years
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
# Create character string without spaces of data
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_code,
data = data_ch,
years = years_ch
)
)
if (http_type(raw_result) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Parse the response from JSON to R
raw_content <- rawToChar(raw_result$content)
# use function from jsonlite to convert response to R data frame
df_content <- fromJSON(raw_content)
if (http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed [%s]\n%s\n<%s>",
status_code(raw_result),
df_content$message,
df_content$documentation_url
),
call. = FALSE
)
}
df_output <- data.frame(
country = character(),
dataset = character(),
years = numeric(),
values = numeric()
)
for (i in 1:length(df_content[[1]])) {
country_name <- df_content$countryName[i]
# loop through all datasets (exclude countryCode and countryName)
for (j in 3:length(df_content)) {
# Skip this iterration if this dataset is empty (no values received from API)
if (length(df_content[[j]][[i]]) == 0) {
next
}
# take years of the jth dataset for the ith country
years_j <- df_content[[j]][[i]][[1]]
# take value of the jth dataset for the ith country
value_j <- df_content[[j]][[i]][[2]]
# create vestor of countryNames
country_j <-
rep.int(country_name, length(value_j))
# Create vector of dataset name
dataset_j <-
rep.int(names(df_content)[j], length(value_j))
# create temp dataframe
output_temp <- data.frame(
country = country_j,
dataset = dataset_j,
years = years_j,
values = value_j
)
# merge the rows to df_output
df_output <- rbind(df_output, output_temp)
}
}
result <<- df_output
}
)
)
api_key = "97c1f72e01dd5ba3"
country_code = "us,gb,se"
data = c("population","birth_rate")
data = c("population","birth_rate","co2_emissions","fifa","hdi")
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
test3$result
ls()
library(INQStatsR)
api_key = "97c1f72e01dd5ba3"
country_code = "us,gb,se"
data = c("population","birth_rate")
data = c("population","birth_rate","co2_emissions","fifa","hdi")
years = 1990:2000
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
test3$result
api_key = "123"
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
test3$result
data = c("population","birth_rate")
test3 <- databycountry$new(api_key= "a3", country_code = "us,gb,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_code,
data = data_ch,
years = years_ch
)
)
raw_result
http_type(raw_result)
raw_content <- rawToChar(raw_result$content)
df_content <- fromJSON(raw_content)
df_content
http_error(raw_result)
http_error(df_content)
http_error(raw_result)
df_content[[1]]
df_content[[1]] == "error"
status_code(raw_result)
df_content$message
api_key = "97c1f72e01dd5ba3"
years = "1h1h1"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_code,
data = data_ch,
years = years #years_ch
)
)
http_type(raw_result)
raw_content <- rawToChar(raw_result$content)
df_content <- fromJSON(raw_content)
df_content
status_code(raw_result)
years = 1990:2017
api_key = "123"
years = 1990:2017
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_code,
data = data_ch,
years = years_ch
)
)
raw_content <- rawToChar(raw_result$content)
df_content <- fromJSON(raw_content)
if (df_content[[1]] == "error"|http_error(resp)) {
stop(
sprintf(
"INQStats API request failed [%s]\n<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
if (df_content[[1]] == "error"|http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed [%s]\n<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
if (df_content[[1]] == "error"|http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed [%s]\n<%s>",
paste("status code:"status_code(raw_result)),
paste("msg:"df_content$msg)
),
call. = FALSE
)
}
if (df_content[[1]] == "error"|http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed [status code:%s]\n<msg:%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
stop(
sprintf(
"INQStats API request failed [status_code:%s]\n<msg:%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
if (df_content[[1]] == "error"|http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed, status_code:[%s]\nmsg:<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
if (df_content[[1]] == "error"|http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed.\n status_code:[%s]\nmsg:<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
if (df_content[[1]] == "error"|http_error(raw_result)) {
stop(
sprintf(
"INQStats API request failed.\nstatus_code:[%s]\nmsg:<%s>",
status_code(raw_result),
df_content$msg
),
call. = FALSE
)
}
library(INQStatsR)
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se", data = c("population","birth_rate","co2_emissions","corruption_index","death_rate"),years = 1990:2015)
library(INQStatsR)
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se", data = c("population","birth_rate","co2_emissions","corruption_index","death_rate"),years = 1990:2015)
test3$result
test3 <- databycountry$new(api_key= "a3", country_code = "us,gb,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
library(INQStatsR)
library(INQStatsR)
library(INQStatsR)
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se", data = c("population","birth_rate","co2_emissions","corruption_index","death_rate"),years = 1990:2015)
test3$result
library(jsonlite)
library(httr)
devtools::use_testthat()
library(INQStatsR)
devtools::use_testthat()
library(INQStatsR)
devtools::use_testthat()
devtools::use_testthat()
install.packages(shiny)
install.packages("shiny")
install.packages("dplyr")
library(INQStatsR)
devtools::use_testthat()
library(INQStatsR)
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,gb,se", data = c("population","birth_rate","co2_emissions","corruption_index","death_rate"),years = 1990:2015)
runShinyapp(test3$result)
runShinyapp(test3$result)
library(INQStatsR)
library(INQStatsR)
runShinyapp(test3$result)
test2 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,uk,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
api_key = "97c1f72e01dd5ba3"
country_code = "us,uk,se"
data = c("population","birth_rate")
years = 1990:2017
years_ch <- gsub(" ", "", toString(years), fixed = TRUE)
data_ch <- gsub(" ", "", toString(data), fixed = TRUE)
url <-  "http://inqstatsapi.inqubu.com"
raw_result <-
GET(
url,
query = list(
api_key = api_key,
countries = country_code,
data = data_ch,
years = years_ch
)
)
http_type(raw_result)
raw_result
raw_content <- rawToChar(raw_result$content)
raw_content
match("{\"type\":\"error\",\"msg\":\"Invalid data argument.\"}","error")
substr("{\"type\":\"error\",\"msg\":\"Invalid data argument.\"}","error")
pmatch(raw_content,"error")
pmatch(raw_content,c("error"))
pmatch("error",raw_content)
grep(raw_content,"error")
regexpr(raw_content,"error")
raw_content
class(raw_content)
grep(raw_content,"error",fixed = TRUE)
grep(raw_content,"error",fixed = FALSE)
grep(raw_content,"error",fixed = TRUE, value = TRUE)
grep(raw_content,"error",fixed = TRUE, value = FALSE)
sub("{","[",raw_content)
sub("{}","[",raw_content)
?substr()
a <- substr(raw_content, 3, nchar(raw_content)-3)
a
raw_content
a <- substr(raw_content, 2, nchar(raw_content)-2)
a
a <- substr(raw_content, 2, nchar(raw_content)-1)
a
grep("error",a)
grep("blabla",a)
library(INQStatsR)
test2 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,uk,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
library(INQStatsR)
test2 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = "us,uk,se,lt", data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
library(INQStatsR)
library(INQStatsR)
expect_error(test1 <- databycountry$new(api_key= "a3", country_code = c("us","gb","se","lt"), data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015))
library(INQStatsR)
test2 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = c("us","uk","se","lt"), data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015)
library(INQStatsR)
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = c("us","gb","se","lt"), data = c("population","birth_rate","co2_emissions","corruption_index","death_rate"),years = 1990:2015)
class(test3)
class(test3)[1]
test3
class(test3)[1]
test_that("class is correct", {
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = c("us","gb","se","lt"), data = c("population","birth_rate","co2_emissions","corruption_index","death_rate"),years = 1990:2015)
expect_true(class(test3)[1] == "databycountry")
})
library("testthat", lib.loc="~/R/win-library/3.4")
test_that("class is correct", {
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = c("us","gb","se","lt"), data = c("population","birth_rate","co2_emissions","corruption_index","death_rate"),years = 1990:2015)
expect_true(class(test3)[1] == "databycountry")
})
test_that("Error messages are returned if API returns error", {
expect_error(databycountry$new(api_key= "a3", country_code = c("us","gb","se","lt"), data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015))
expect_error(databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = c("us","uk"), data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015))
})
library(INQStatsR)
test_that("Error messages are returned if API returns error", {
expect_error(databycountry$new(api_key= "a3", country_code = c("us","gb","se","lt"), data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015))
expect_error(databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = c("us","uk"), data = c("population","birth_rate","co2_emissions","fifa","hdi"),years = 1990:2015))
})
test_that("class is correct", {
test3 <- databycountry$new(api_key= "97c1f72e01dd5ba3", country_code = c("us","gb","se","lt"), data = c("population","birth_rate","co2_emissions","corruption_index","death_rate"),years = 1990:2015)
expect_true(class(test3)[1] == "databycountry")
})
